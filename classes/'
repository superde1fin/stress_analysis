#include <vector>
#include <string>
#include <map>
#include <iostream>

#include "Molecule.hpp"
#include "Helper.hpp"

using namespace std;

Molecule::Molecule(int type, string type_str, int id){
    Molecule::type = type;
    Molecule::type_str = type_str;
    Molecule::id = id;
    }

vector<Molecule*> Molecule::get_bonds(){
    return Molecule::bonds;
    }

Molecule* Molecule::add_bond(int type, string type_str, int id){
    Molecule* ml = new Molecule(type, type_str, id);
    ml -> add_bond(Molecule::this);
    Molecule::bonds.push_back(ml);
    return ml;
    }

bool Molecule::is_atom(){
    return !Molecule::bonds.size();
    }

bool Molecule::in_molecule(int type){
    if(type == Molecule::type){
        return true;
        }
    else{
        bool res = false;
        for(Molecule* ml : Molecule::bonds){
            res = ml -> in_molecule(type);
            if(res){break;}
            }
        return res;
        }
    }

Molecule::~Molecule(){
    for(Molecule* ml : Molecule::bonds){
        delete ml;
        }
    }

map<int, tuple<vector<int>, int, string>> Molecule::get_count(){
    cout << "Looking at molecule: " << Molecule::type << " with id: " << Molecule::id << endl;
    bool done;
    map<int, tuple<vector<int>, int, string>> count;
    vector<int> ids = {Molecule::id};
    get<vector<int>>(count[Molecule::type]) = ids;
    get<int>(count[Molecule::type]) = 1;
    get<string>(count[Molecule::type]) = Molecule::type_str;
    map<int, tuple<vector<int>, int, string>> temp_count;
    vector<int> non_intersection;
    vector<int>* existing_ids;
    for(Molecule* ml : Molecule::bonds){
        if(ml -> is_atom()){
            cout << "The molecule " << ml -> id << " is an atom\n";
            get<vector<int>>(count[ml -> get_type()]).push_back(ml -> id);
            get<int>(count[ml -> get_type()])++;
            get<string>(count[ml -> get_type()]) = ml -> get_type_str();
            cout << ml -> get_type() << " " << get<int>(count[ml -> get_type()]) << " " << get<string>(count[ml -> get_type()]) << endl;
            }
        else{
            temp_count = ml -> get_count();
            for(auto it = temp_count.begin(); it != temp_count.end(); ++it){
                if(count.count(it -> first)){
                    non_intersection = Helper::not_in(get<vector<int>>(count[it -> first]), get<vector<int>>(it -> second));
                    get<int>(count[it -> first]) += non_intersection.size();
                    existing_ids = &get<vector<int>>(count[it -> first]);
                    (*existing_ids).insert(existing_ids -> end(), non_intersection.begin(), non_intersection.end());
                    get<string>(count[it -> first]) = get<string>(it -> second);
                    }
                else{
                    get<int>(count[it -> first]) = get<int>(it -> second);
                    get<vector<int>>(count[it -> first]) = get<vector<int>>(it -> second);
                    get<string>(count[it -> first]) = get<string>(it -> second);
                    }
                }
            }
        }
    cout << "----------------- Current count for atom: " << Molecule::id << endl;
    for(auto it = count.begin(); it != count.end(); ++it){
        cout << it -> first << " " << get<string>(it -> second) << " " << get<int>(it -> second) << endl;
        }
    return count;
    }

string Molecule::get_name(){
    string name = "";
    map<int, tuple<vector<int>, int, string>> count = Molecule::get_count();
    for(auto it = count.begin(); it != count.end(); ++it){
        name += (get<string>(it -> second) + "(" + Helper::to_str(get<int>(it -> second)) + ")");
        }
    return name;
    }

Molecule* Molecule::add_bond(Molecule* ml){
    Molecule::bonds.push_back(ml);
    return ml;
    }

string Molecule::get_type_str(){
    return Molecule::type_str;
    }

int Molecule::get_type(){
    return Molecule::type;
    }

int Molecule::count_atoms(){
    int total = 0;
    map<int, tuple<vector<int>, int, string>> count = Molecule::get_count();
    for(auto it = count.begin(); it != count.end(); ++it){
        total += get<int>(it -> second);
        }
    return total;
    }

int Molecule::dist_to(int type, set<int> *exclude){
    int res;
    int iter_res;
    if(!Helper::element_in(Molecule::id, *exclude)){
        if(Molecule::get_type() == type){
            return 0;
            }
        else{
            if(Molecule::is_atom()){
                return numeric_limits<int>::max();
                }
            }
        exclude -> insert(ml -> id);
        for(Molecule* ml : Molecule::bonds){
            if(!Helper::element_in(ml -> id, *exclude)){
                iter_res = ml -> find_type(type, exclude);
                }
            }
        res.insert(res.end(), iter_res.begin(), iter_res.end());
        }
    return res;
    }

